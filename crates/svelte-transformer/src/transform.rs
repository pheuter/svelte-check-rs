//! Main transformation logic.

use crate::props::{extract_props_info, generate_props_type};
use crate::runes::transform_runes_with_options;
use crate::template::generate_template_check_with_spans;
use crate::types::{component_name_from_path, ComponentExports};
use source_map::{SourceMap, SourceMapBuilder};
use svelte_parser::{ScriptLang, SvelteDocument};

/// The kind of SvelteKit route file.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SvelteKitRouteKind {
    /// `+page.svelte` - Page component
    Page,
    /// `+layout.svelte` - Layout component
    Layout,
    /// `+error.svelte` - Error component
    Error,
    /// `+page.server.ts/js` - Server-side page load
    PageServer,
    /// `+layout.server.ts/js` - Server-side layout load
    LayoutServer,
    /// `+server.ts/js` - API endpoint
    Server,
    /// Not a SvelteKit route file
    None,
}

impl SvelteKitRouteKind {
    /// Detect the kind of SvelteKit route from a filename.
    ///
    /// Handles SvelteKit's naming conventions including:
    /// - `+page.svelte`, `+layout.svelte`, `+error.svelte`
    /// - `+page@.svelte`, `+layout@.svelte` (breaking out of layouts)
    /// - `+page@group.svelte` (named layout resets)
    pub fn from_filename(filename: &str) -> Self {
        let basename = std::path::Path::new(filename)
            .file_name()
            .and_then(|s| s.to_str())
            .unwrap_or(filename);

        // Handle base names and variants with @ suffix (layout resets)
        // e.g., +page.svelte, +page@.svelte, +page@group.svelte
        if basename.starts_with("+page") && basename.ends_with(".svelte") {
            return Self::Page;
        }
        if basename.starts_with("+layout") && basename.ends_with(".svelte") {
            return Self::Layout;
        }
        if basename.starts_with("+error") && basename.ends_with(".svelte") {
            return Self::Error;
        }
        if basename.starts_with("+page.server.") {
            return Self::PageServer;
        }
        if basename.starts_with("+layout.server.") {
            return Self::LayoutServer;
        }
        if basename.starts_with("+server.") {
            return Self::Server;
        }

        Self::None
    }

    /// Get the data type name for this route kind.
    pub fn data_type(&self) -> Option<&'static str> {
        match self {
            Self::Page | Self::PageServer => Some("PageData"),
            Self::Layout | Self::LayoutServer => Some("LayoutData"),
            _ => None,
        }
    }
}

/// Options for transformation.
#[derive(Debug, Clone, Default)]
pub struct TransformOptions {
    /// The filename of the source file.
    pub filename: Option<String>,
    /// Whether to generate source maps.
    pub source_maps: bool,
}

/// The result of transformation.
#[derive(Debug)]
pub struct TransformResult {
    /// The generated TSX code.
    pub tsx_code: String,
    /// The source map for position mapping.
    pub source_map: SourceMap,
    /// Exported component types.
    pub exports: ComponentExports,
}

/// Transforms a Svelte document to TSX.
pub fn transform(doc: &SvelteDocument, options: TransformOptions) -> TransformResult {
    let mut output = String::new();
    let mut builder = SourceMapBuilder::new();
    let mut exports = ComponentExports::default();

    // Detect SvelteKit route kind for type inference
    let route_kind = options
        .filename
        .as_deref()
        .map(SvelteKitRouteKind::from_filename)
        .unwrap_or(SvelteKitRouteKind::None);

    // Add file header
    let header = "// Generated by svelte-check-rs\n// This file is for type-checking only\n\n";
    output.push_str(header);
    builder.add_generated(header);

    // Add Svelte imports - use Component and ComponentProps for Svelte 5
    let imports = "import type { Component, ComponentProps } from 'svelte';\n";
    output.push_str(imports);
    builder.add_generated(imports);

    // Add SvelteKit type imports for route files
    if let Some(data_type) = route_kind.data_type() {
        let sveltekit_import = format!("import type {{ {} }} from './$types';\n\n", data_type);
        output.push_str(&sveltekit_import);
        builder.add_generated(&sveltekit_import);
    } else {
        output.push('\n');
        builder.add_generated("\n");
    }

    // Add helper functions for template type-checking
    let helpers = r#"// Helper functions for template type-checking
declare function __svelte_each_indexed<T>(arr: T[]): [number, T][];
declare function __svelte_is_empty<T>(arr: T[]): boolean;

// Helper to check component props without instantiation
declare function __svelte_check_props<C extends Component<any>>(
  component: C,
  props: ComponentProps<C>
): void;

"#;
    output.push_str(helpers);
    builder.add_generated(helpers);

    // Get the default props type for SvelteKit route files
    let default_props_type = route_kind.data_type();

    // Transform module script if present
    if let Some(module) = &doc.module_script {
        let section = "// === MODULE SCRIPT ===\n";
        output.push_str(section);
        builder.add_generated(section);

        let base_offset: u32 = module.content_span.start.into();
        let rune_result =
            transform_runes_with_options(&module.content, base_offset, default_props_type);
        output.push_str(&rune_result.output);
        output.push('\n');

        // Add source mapping for the script content
        // For now, use simple 1:1 mapping; in a full implementation,
        // we would incorporate rune_result.mappings for precise rune spans
        builder.add_source(module.content_span.start, &rune_result.output);
        builder.add_generated("\n");
    }

    // Transform instance script if present
    if let Some(instance) = &doc.instance_script {
        let section = "// === INSTANCE SCRIPT ===\n";
        output.push_str(section);
        builder.add_generated(section);

        let base_offset: u32 = instance.content_span.start.into();
        let rune_result =
            transform_runes_with_options(&instance.content, base_offset, default_props_type);
        output.push_str(&rune_result.output);
        output.push('\n');

        builder.add_source(instance.content_span.start, &rune_result.output);
        builder.add_generated("\n");

        // Extract props type from the instance script
        if let Some(props_info) =
            extract_props_info(&rune_result.output, &instance.content, base_offset)
        {
            exports.props_type = Some(generate_props_type(&props_info));
        }
    }

    // Generate template type-check block with span tracking
    let template_result = generate_template_check_with_spans(&doc.fragment);
    if !template_result.code.is_empty() {
        // Use the structured template code which properly handles component props,
        // object literals, and control flow structures
        output.push_str(&template_result.code);

        // For now, just advance the offset without per-expression mapping.
        // The structured template code includes control flow (if/for) which makes
        // precise expression mapping more complex. We rely on tsgo to report
        // line/column which can be roughly matched back to source.
        builder.add_generated(&template_result.code);
    }

    // Generate component export
    let export_section = "\n// === COMPONENT TYPE EXPORT ===\n";
    output.push_str(export_section);
    builder.add_generated(export_section);

    let component_name = options
        .filename
        .as_deref()
        .map(component_name_from_path)
        .unwrap_or_else(|| "Component".to_string());

    // Determine if we should use TypeScript
    let is_typescript = doc
        .instance_script
        .as_ref()
        .map(|s| s.lang == ScriptLang::TypeScript)
        .unwrap_or(false)
        || doc
            .module_script
            .as_ref()
            .map(|s| s.lang == ScriptLang::TypeScript)
            .unwrap_or(false);

    // Generate the export using ComponentExports helper
    let export_line = exports.generate_export(&component_name, is_typescript);

    output.push_str(&export_line);
    builder.add_generated(&export_line);

    TransformResult {
        tsx_code: output,
        source_map: builder.build(),
        exports,
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use svelte_parser::parse;

    #[test]
    fn test_transform_empty() {
        let doc = parse("").document;
        let result = transform(&doc, TransformOptions::default());
        assert!(result.tsx_code.contains("SvelteComponent"));
    }

    #[test]
    fn test_transform_with_script() {
        let doc = parse("<script>let x = $state(0);</script>").document;
        let result = transform(&doc, TransformOptions::default());
        assert!(result.tsx_code.contains("let x = 0"));
    }

    #[test]
    fn test_transform_with_expression() {
        let doc = parse("<div>{value}</div>").document;
        let result = transform(&doc, TransformOptions::default());
        assert!(result.tsx_code.contains("value"));
    }

    #[test]
    fn test_transform_with_typescript() {
        let doc = parse("<script lang=\"ts\">let x: number = $state(0);</script>").document;
        let result = transform(&doc, TransformOptions::default());
        assert!(result.tsx_code.contains("let x: number = 0"));
    }

    #[test]
    fn test_transform_with_filename() {
        let doc = parse("").document;
        let result = transform(
            &doc,
            TransformOptions {
                filename: Some("Counter.svelte".to_string()),
                ..Default::default()
            },
        );
        // Uses internal name to avoid conflicts with imports
        assert!(result.tsx_code.contains("__SvelteComponent_Counter_"));
    }
}
