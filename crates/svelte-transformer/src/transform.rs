//! Main transformation logic.

use crate::props::{extract_props_info, generate_props_type};
use crate::runes::transform_runes;
use crate::template::generate_template_check_with_spans;
use crate::types::{component_name_from_path, ComponentExports};
use source_map::{SourceMap, SourceMapBuilder};
use svelte_parser::{ScriptLang, SvelteDocument};

/// Options for transformation.
#[derive(Debug, Clone, Default)]
pub struct TransformOptions {
    /// The filename of the source file.
    pub filename: Option<String>,
    /// Whether to generate source maps.
    pub source_maps: bool,
}

/// The result of transformation.
#[derive(Debug)]
pub struct TransformResult {
    /// The generated TSX code.
    pub tsx_code: String,
    /// The source map for position mapping.
    pub source_map: SourceMap,
    /// Exported component types.
    pub exports: ComponentExports,
}

/// Transforms a Svelte document to TSX.
pub fn transform(doc: &SvelteDocument, options: TransformOptions) -> TransformResult {
    let mut output = String::new();
    let mut builder = SourceMapBuilder::new();
    let mut exports = ComponentExports::default();

    // Add file header
    let header = "// Generated by svelte-check-rs\n// This file is for type-checking only\n\n";
    output.push_str(header);
    builder.add_generated(header);

    // Add Svelte imports
    let imports = "import { SvelteComponent } from 'svelte';\n\n";
    output.push_str(imports);
    builder.add_generated(imports);

    // Transform module script if present
    if let Some(module) = &doc.module_script {
        let section = "// === MODULE SCRIPT ===\n";
        output.push_str(section);
        builder.add_generated(section);

        let base_offset: u32 = module.content_span.start.into();
        let rune_result = transform_runes(&module.content, base_offset);
        output.push_str(&rune_result.output);
        output.push('\n');

        // Add source mapping for the script content
        // For now, use simple 1:1 mapping; in a full implementation,
        // we would incorporate rune_result.mappings for precise rune spans
        builder.add_source(module.content_span.start, &rune_result.output);
        builder.add_generated("\n");
    }

    // Transform instance script if present
    if let Some(instance) = &doc.instance_script {
        let section = "// === INSTANCE SCRIPT ===\n";
        output.push_str(section);
        builder.add_generated(section);

        let base_offset: u32 = instance.content_span.start.into();
        let rune_result = transform_runes(&instance.content, base_offset);
        output.push_str(&rune_result.output);
        output.push('\n');

        builder.add_source(instance.content_span.start, &rune_result.output);
        builder.add_generated("\n");

        // Extract props type from the instance script
        if let Some(props_info) =
            extract_props_info(&rune_result.output, &instance.content, base_offset)
        {
            exports.props_type = Some(generate_props_type(&props_info));
        }
    }

    // Generate template type-check block with span tracking
    let template_result = generate_template_check_with_spans(&doc.fragment);
    if !template_result.code.is_empty() {
        // We emit the template check code and track expression mappings
        // The template check code is mostly generated, but expressions should map back
        let template_header = "\n// === TEMPLATE TYPE-CHECK BLOCK ===\n// This is never executed, just type-checked\nfunction __svelte_template_check__() {\n";
        output.push_str(template_header);
        builder.add_generated(template_header);

        // Add each expression with its source mapping
        for expr in &template_result.expressions {
            let indent = "  ";
            output.push_str(indent);
            builder.add_generated(indent);

            output.push_str(&expr.expression);
            // Map the expression text back to its original span
            builder.add_transformed(expr.span, &expr.expression);

            output.push_str(";\n");
            builder.add_generated(";\n");
        }

        let template_footer = "}\n";
        output.push_str(template_footer);
        builder.add_generated(template_footer);
    }

    // Generate component export
    let export_section = "\n// === COMPONENT TYPE EXPORT ===\n";
    output.push_str(export_section);
    builder.add_generated(export_section);

    let component_name = options
        .filename
        .as_deref()
        .map(component_name_from_path)
        .unwrap_or_else(|| "Component".to_string());

    // Determine if we should use TypeScript
    let is_typescript = doc
        .instance_script
        .as_ref()
        .map(|s| s.lang == ScriptLang::TypeScript)
        .unwrap_or(false)
        || doc
            .module_script
            .as_ref()
            .map(|s| s.lang == ScriptLang::TypeScript)
            .unwrap_or(false);

    // Generate the export using ComponentExports helper
    let export_line = exports.generate_export(&component_name, is_typescript);

    output.push_str(&export_line);
    builder.add_generated(&export_line);

    TransformResult {
        tsx_code: output,
        source_map: builder.build(),
        exports,
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use svelte_parser::parse;

    #[test]
    fn test_transform_empty() {
        let doc = parse("").document;
        let result = transform(&doc, TransformOptions::default());
        assert!(result.tsx_code.contains("SvelteComponent"));
    }

    #[test]
    fn test_transform_with_script() {
        let doc = parse("<script>let x = $state(0);</script>").document;
        let result = transform(&doc, TransformOptions::default());
        assert!(result.tsx_code.contains("let x = 0"));
    }

    #[test]
    fn test_transform_with_expression() {
        let doc = parse("<div>{value}</div>").document;
        let result = transform(&doc, TransformOptions::default());
        assert!(result.tsx_code.contains("value"));
    }

    #[test]
    fn test_transform_with_typescript() {
        let doc = parse("<script lang=\"ts\">let x: number = $state(0);</script>").document;
        let result = transform(&doc, TransformOptions::default());
        assert!(result.tsx_code.contains("let x: number = 0"));
    }

    #[test]
    fn test_transform_with_filename() {
        let doc = parse("").document;
        let result = transform(
            &doc,
            TransformOptions {
                filename: Some("Counter.svelte".to_string()),
                ..Default::default()
            },
        );
        assert!(result.tsx_code.contains("class Counter"));
    }
}
