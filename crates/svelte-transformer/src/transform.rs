//! Main transformation logic.

use crate::runes::transform_runes;
use crate::template::generate_template_check;
use crate::types::ComponentExports;
use source_map::{SourceMap, SourceMapBuilder};
use svelte_parser::{ScriptLang, SvelteDocument};

/// Options for transformation.
#[derive(Debug, Clone, Default)]
pub struct TransformOptions {
    /// The filename of the source file.
    pub filename: Option<String>,
    /// Whether to generate source maps.
    pub source_maps: bool,
}

/// The result of transformation.
#[derive(Debug)]
pub struct TransformResult {
    /// The generated TSX code.
    pub tsx_code: String,
    /// The source map for position mapping.
    pub source_map: SourceMap,
    /// Exported component types.
    pub exports: ComponentExports,
}

/// Transforms a Svelte document to TSX.
pub fn transform(doc: &SvelteDocument, options: TransformOptions) -> TransformResult {
    let mut output = String::new();
    let mut builder = SourceMapBuilder::new();
    let exports = ComponentExports::default();

    // Add file header
    output.push_str("// Generated by svelte-check-rs\n");
    output.push_str("// This file is for type-checking only\n\n");
    builder.add_generated(&output);

    // Add Svelte imports
    output.push_str("import { SvelteComponent } from 'svelte';\n\n");
    builder.add_generated("import { SvelteComponent } from 'svelte';\n\n");

    // Transform module script if present
    if let Some(module) = &doc.module_script {
        output.push_str("// === MODULE SCRIPT ===\n");
        builder.add_generated("// === MODULE SCRIPT ===\n");

        let (transformed, _runes) = transform_runes(&module.content);
        output.push_str(&transformed);
        output.push('\n');

        // Add source mapping for the script content
        builder.add_source(module.content_span.start, &transformed);
        builder.add_generated("\n");
    }

    // Transform instance script if present
    if let Some(instance) = &doc.instance_script {
        output.push_str("// === INSTANCE SCRIPT ===\n");
        builder.add_generated("// === INSTANCE SCRIPT ===\n");

        let (transformed, _runes) = transform_runes(&instance.content);
        output.push_str(&transformed);
        output.push('\n');

        builder.add_source(instance.content_span.start, &transformed);
        builder.add_generated("\n");
    }

    // Generate template type-check block
    let template_check = generate_template_check(&doc.fragment);
    if !template_check.is_empty() {
        output.push_str(&template_check);
        builder.add_generated(&template_check);
    }

    // Generate component export
    output.push_str("\n// === COMPONENT TYPE EXPORT ===\n");
    builder.add_generated("\n// === COMPONENT TYPE EXPORT ===\n");

    let component_name = options
        .filename
        .as_ref()
        .and_then(|f| {
            std::path::Path::new(f)
                .file_stem()
                .and_then(|s| s.to_str())
                .map(|s| s.to_string())
        })
        .unwrap_or_else(|| "Component".to_string());

    // Determine if we should use TypeScript
    let is_typescript = doc
        .instance_script
        .as_ref()
        .map(|s| s.lang == ScriptLang::TypeScript)
        .unwrap_or(false)
        || doc
            .module_script
            .as_ref()
            .map(|s| s.lang == ScriptLang::TypeScript)
            .unwrap_or(false);

    let export_line = if is_typescript {
        format!(
            "export default class {} extends SvelteComponent<{{}}, {{}}, {{}}> {{}}\n",
            component_name
        )
    } else {
        format!(
            "export default class {} extends SvelteComponent {{}}\n",
            component_name
        )
    };

    output.push_str(&export_line);
    builder.add_generated(&export_line);

    TransformResult {
        tsx_code: output,
        source_map: builder.build(),
        exports,
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use svelte_parser::parse;

    #[test]
    fn test_transform_empty() {
        let doc = parse("").document;
        let result = transform(&doc, TransformOptions::default());
        assert!(result.tsx_code.contains("SvelteComponent"));
    }

    #[test]
    fn test_transform_with_script() {
        let doc = parse("<script>let x = $state(0);</script>").document;
        let result = transform(&doc, TransformOptions::default());
        assert!(result.tsx_code.contains("let x = 0"));
    }

    #[test]
    fn test_transform_with_expression() {
        let doc = parse("<div>{value}</div>").document;
        let result = transform(&doc, TransformOptions::default());
        assert!(result.tsx_code.contains("value"));
    }

    #[test]
    fn test_transform_with_typescript() {
        let doc = parse("<script lang=\"ts\">let x: number = $state(0);</script>").document;
        let result = transform(&doc, TransformOptions::default());
        assert!(result.tsx_code.contains("let x: number = 0"));
    }

    #[test]
    fn test_transform_with_filename() {
        let doc = parse("").document;
        let result = transform(
            &doc,
            TransformOptions {
                filename: Some("Counter.svelte".to_string()),
                ..Default::default()
            },
        );
        assert!(result.tsx_code.contains("class Counter"));
    }
}
