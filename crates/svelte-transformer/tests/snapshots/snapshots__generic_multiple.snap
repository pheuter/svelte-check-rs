---
source: crates/svelte-transformer/tests/snapshots.rs
assertion_line: 44
expression: output
---
=== Source (Combobox.svelte) ===
<script
  lang="ts"
  generics="T extends {label: string; value: string}, TMode extends 'single' | 'multiple'"
>
    import CheckIcon from '@lucide/svelte/icons/check';
    import type { Snippet } from 'svelte';

    type ValueType<TMode extends 'single' | 'multiple'> = TMode extends 'single' ? string : string[];

    type Props = {
        mode: TMode;
        value?: ValueType<TMode>;
        options: T[];
        item?: Snippet<[T]>;
    };

    let {
        mode,
        value = $bindable((mode === 'multiple' ? [] : '') as ValueType<TMode>),
        options,
        item = itemDefault,
    }: Props = $props();

    const selectedOptions = $derived.by(() => {
        if (mode === 'multiple') {
            return options.filter((opt) => (value as string[]).includes(opt.value));
        } else {
            const found = options.find((f) => f.value === value);
            return found ? [found] : [];
        }
    });
</script>

<div>
    {#each selectedOptions as option}
        <span>{@render item(option)}</span>
        <CheckIcon class="size-4" />
    {/each}
</div>

{#snippet itemDefault(option: T)}
    {option.label}
{/snippet}

=== TSX Output ===
// Generated by svelte-check-rs
// This file is for type-checking only

import type { ComponentInternals as __SvelteComponentInternals, Snippet as __SvelteSnippet } from 'svelte';

// Helper functions for template type-checking
type __SvelteComponent<
  Props extends Record<string, any> = {},
  Exports extends Record<string, any> = {}
> = {
  (this: void, internals: __SvelteComponentInternals, props: Props): {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Props>): void;
  } & Exports;
  element?: typeof HTMLElement;
  z_$$bindings?: string;
};

declare function __svelte_each_indexed<T>(arr: ArrayLike<T> | Iterable<T>): [number, T][];
declare function __svelte_is_empty<T>(arr: ArrayLike<T> | Iterable<T>): boolean;

// Helper to get store value type from store subscription ($store syntax)
declare function __svelte_store_get<T>(store: { subscribe(fn: (value: T) => void): any }): T;

// Helpers for $effect runes (avoid control-flow narrowing during type-checking)
declare function __svelte_effect(fn: () => void | (() => void)): void;
declare function __svelte_effect_pre(fn: () => void | (() => void)): void;
declare function __svelte_effect_root(fn: (...args: any[]) => any): void;

// Helper type to extract store value for typeof expressions
type __StoreValue<S> = S extends { subscribe(fn: (value: infer T) => void): any } ? T : never;

// Helper to mark specific props as optional without expanding complex unions.
type __SvelteOptionalProps<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

// Loosen props to allow extra nested fields while preserving declared shapes.
type __SvelteLoosenField<T> =
  T extends (...args: any) => any ? T :
  T extends readonly any[] ? T :
  T extends object ? T & Record<string, any> : T;
type __SvelteLoosen<T> =
  T extends (...args: any) => any ? T :
  T extends readonly any[] ? T :
  T extends object ? { [K in keyof T]: __SvelteLoosenField<T[K]> } & Record<string, any> : T;

// Helper for $props.<name>() accessors.
type __SveltePropsAccessor<T> = { [K in keyof T]: () => T[K] } & Record<string, () => any>;

// Shared snippet return value to satisfy Snippet return types.
declare const __svelte_snippet_return: ReturnType<__SvelteSnippet<[]>>;

// Helper type for DOM event handlers with typed currentTarget/target
type __SvelteEvent<Target extends EventTarget, E extends Event> = E & {
  currentTarget: Target;
  target: Target;
};

// === INSTANCE SCRIPT ===
import CheckIcon from '@lucide/svelte/icons/check';import type { Snippet } from 'svelte';function __svelte_render<T extends {label: string; value: string}, TMode extends 'single' | 'multiple'>() {
// === SNIPPET DECLARATIONS ===
function __svelte_snippet_params_itemDefault(option: T) {}
const itemDefault: __SvelteSnippet<Parameters<typeof __svelte_snippet_params_itemDefault>> = null as any;


    
    

    type ValueType<TMode extends 'single' | 'multiple'> = TMode extends 'single' ? string : string[];

    type Props = {
        mode: TMode;
        value?: ValueType<TMode>;
        options: T[];
        item?: Snippet<[T]>;
    };

    let {
        mode,
        value = (mode === 'multiple' ? [] : '') as ValueType<TMode>,
        options,
        item = itemDefault,
    }: Props = ({} as __SvelteLoosen<Props>);

    const selectedOptions = (() => {
        if (mode === 'multiple') {
            return options.filter((opt) => (value as string[]).includes(opt.value));
        } else {
            const found = options.find((f) => f.value === value);
            return found ? [found] : [];
        }
    })();


// === TEMPLATE TYPE-CHECK BLOCK ===
// This is never executed, just type-checked
async function __svelte_template_check__() {
  const __each_0 = selectedOptions;
  for (const option of __each_0) {
    item(option);
    CheckIcon(null as any, {
      class: "size-4",
    });
  }
  function itemDefault(option: T) {
    option.label;
    return __svelte_snippet_return;
  }
}
return { props: null as any as __SvelteOptionalProps<Props, "value" | "item">, exports: {}, slots: {}, events: {} };
}

// === COMPONENT TYPE EXPORT ===
type __SvelteProps_Combobox_<T extends {label: string; value: string}, TMode extends 'single' | 'multiple'> = ReturnType<typeof __svelte_render<T, TMode>>["props"];
declare const __SvelteComponent_Combobox_: {
<T extends {label: string; value: string}, TMode extends 'single' | 'multiple'>(this: void, internals: any, props: __SvelteProps_Combobox_<T, TMode>): ReturnType<typeof __svelte_render<T, TMode>>["exports"];
element?: typeof HTMLElement;
z_$$bindings?: any;
};
export default __SvelteComponent_Combobox_;


=== Source Map Mappings: 5 ===
