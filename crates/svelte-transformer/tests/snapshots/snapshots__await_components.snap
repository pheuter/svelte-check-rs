---
source: crates/svelte-transformer/tests/snapshots.rs
assertion_line: 24
expression: output
---
=== Source ===
<script lang="ts">
    import Skeleton from './Skeleton.svelte';
    import UserCard from './UserCard.svelte';
    import ErrorAlert from './ErrorAlert.svelte';

    type User = { id: number; name: string; avatar: string };
    let userPromise: Promise<User> = $state(fetch('/api/user').then(r => r.json()));
</script>

{#await userPromise}
    <Skeleton variant="card" />
{:then user}
    <UserCard {user} />
{:catch error}
    <ErrorAlert {error} />
{/await}

=== TSX Output ===
// Generated by svelte-check-rs
// This file is for type-checking only

import type { ComponentInternals as __SvelteComponentInternals, Snippet as __SvelteSnippet } from 'svelte';

// Helper functions for template type-checking
type __SvelteComponent<
  Props extends Record<string, any> = {},
  Exports extends Record<string, any> = {}
> = {
  (this: void, internals: __SvelteComponentInternals, props: Props): {
    $on?(type: string, callback: (e: any) => void): () => void;
    $set?(props: Partial<Props>): void;
  } & Exports;
  element?: typeof HTMLElement;
  z_$$bindings?: string;
};

declare function __svelte_each_indexed<T>(arr: ArrayLike<T> | Iterable<T>): [number, T][];
declare function __svelte_is_empty<T>(arr: ArrayLike<T> | Iterable<T>): boolean;

// Helper to get store value type from store subscription ($store syntax)
declare function __svelte_store_get<T>(store: { subscribe(fn: (value: T) => void): any }): T;

// Helpers for $effect runes (avoid control-flow narrowing during type-checking)
declare function __svelte_effect(fn: () => void | (() => void)): void;
declare function __svelte_effect_pre(fn: () => void | (() => void)): void;
declare function __svelte_effect_root(fn: (...args: any[]) => any): void;

// Helper type to extract store value for typeof expressions
type __StoreValue<S> = S extends { subscribe(fn: (value: infer T) => void): any } ? T : never;

// Helper to mark specific props as optional without expanding complex unions.
type __SvelteOptionalProps<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

// Loosen props to allow extra nested fields while preserving declared shapes.
type __SvelteLoosenField<T> =
  T extends (...args: any) => any ? T :
  T extends readonly any[] ? T :
  T extends object ? T & Record<string, any> : T;
type __SvelteLoosen<T> =
  T extends (...args: any) => any ? T :
  T extends readonly any[] ? T :
  T extends object ? { [K in keyof T]: __SvelteLoosenField<T[K]> } & Record<string, any> : T;

// Helper for $props.<name>() accessors.
type __SveltePropsAccessor<T> = { [K in keyof T]: () => T[K] } & Record<string, () => any>;

// Shared snippet return value to satisfy Snippet return types.
declare const __svelte_snippet_return: ReturnType<__SvelteSnippet<[]>>;

// Helper type for DOM event handlers with typed currentTarget/target
type __SvelteEvent<Target extends EventTarget, E extends Event> = E & {
  currentTarget: Target;
  target: Target;
};

// === INSTANCE SCRIPT ===

    import Skeleton from './Skeleton.svelte';
    import UserCard from './UserCard.svelte';
    import ErrorAlert from './ErrorAlert.svelte';

    type User = { id: number; name: string; avatar: string };
    let userPromise: Promise<User> = fetch('/api/user').then(r => r.json());


// === TEMPLATE TYPE-CHECK BLOCK ===
// This is never executed, just type-checked
async function __svelte_template_check__() {
  const __await_0 = userPromise;
  {
    // pending
    Skeleton(null as any, {
      variant: "card",
    });
  }
  {
    const __then_0 = async () => {
      const user: Awaited<typeof __await_0> = await __await_0;
      UserCard(null as any, {
        user,
      });
    };
    void __then_0();
  }
  {
    const error: unknown = __svelte_catch_error(__await_0);
    ErrorAlert(null as any, {
      error,
    });
  }
}

// === COMPONENT TYPE EXPORT ===
type __SvelteProps_Test_ = {};
declare const __SvelteComponent_Test_: __SvelteComponent<__SvelteProps_Test_>;
export default __SvelteComponent_Test_;


=== Source Map Mappings: 8 ===
