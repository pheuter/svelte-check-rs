---
source: crates/svelte-transformer/tests/snapshots.rs
assertion_line: 25
expression: output
---
=== Source ===
<div style:color="red" style:background-color="blue">Styled</div>

=== TSX Output ===
// Generated by svelte-check-rs
// This file is for type-checking only

import type { Component as __SvelteComponentType, ComponentInternals as __SvelteComponentInternals, Snippet as __SvelteSnippet, SvelteComponent as __SvelteLegacyComponent } from 'svelte';
import type { SvelteHTMLElements as __SvelteHTMLElements, HTMLAttributes as __SvelteHTMLAttributes } from 'svelte/elements';

// Helper functions for template type-checking
type __SvelteCssProps = { [K in `--${string}`]?: string | number };

// Isomorphic component type that supports both constructor (new) and call signatures
interface __SvelteComponent<
  Props extends Record<string, any> = {},
  Exports extends Record<string, any> = {}
> {
  // Constructor signature for `new Component({ target, props })`
  new (options: { target: any; props?: Props & __SvelteCssProps }): __SvelteLegacyComponent<Props, any, any> & Exports;
  // Call signature for Svelte 5 function components
  (internal: unknown, props: Props & __SvelteCssProps): Exports;
}

// Normalize legacy class components to a callable form.
type __SvelteCallableComponent<T> =
  T extends { new (options: { target: any; props?: infer P }): infer I }
    ? (internal: any, props: NonNullable<P>) => I
    : T;

type __SvelteEachItem<T> =
  T extends ArrayLike<infer U> ? U :
  T extends Iterable<infer U> ? U :
  never;

declare function __svelte_each_indexed<
  T extends ArrayLike<unknown> | Iterable<unknown> | null | undefined
>(arr: T): [number, __SvelteEachItem<T>][];
declare function __svelte_is_empty<T extends ArrayLike<unknown> | Iterable<unknown> | null | undefined>(arr: T): boolean;

// Helper to get store value type from store subscription ($store syntax)
declare function __svelte_store_get<T>(store: { subscribe(fn: (value: T) => void): any }): T;

// Helpers for $effect runes (avoid control-flow narrowing during type-checking)
declare function __svelte_effect(fn: () => void | (() => void)): void;
declare function __svelte_effect_pre(fn: () => void | (() => void)): void;
declare function __svelte_effect_root(fn: (...args: any[]) => any): void;

// Helper type to extract store value for typeof expressions
type __StoreValue<S> = S extends { subscribe(fn: (value: infer T) => void): any } ? T : never;

// Helper to mark specific props as optional without expanding complex unions.
type __SvelteOptionalProps<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

// Loosen props to allow extra top-level fields while preserving declared shapes.
type __SvelteLoosen<T> =
  T extends (...args: any) => any ? T :
  T extends readonly any[] ? T :
  T extends object ? { [K in keyof T]: T[K]; [key: string]: unknown } : T;

// Helper for $props.<name>() accessors.
type __SveltePropsAccessor<T> = { [K in keyof T]: () => T[K] } & Record<string, () => any>;

// Shared snippet return value to satisfy Snippet return types.
declare const __svelte_snippet_return: ReturnType<__SvelteSnippet<[]>>;

// Helper type for DOM event handlers with typed currentTarget/target
type __SvelteEvent<Target extends EventTarget, E extends Event> = E & {
  currentTarget: Target;
  target: Target;
};

// Backwards-compatibility namespace for libraries augmenting `svelteHTML`.
declare global {
  namespace svelteHTML {
    interface HTMLAttributes<T extends EventTarget = any> {}
  }
}

// Helper types for element attribute name checking.
type __SvelteIntrinsicElements = __SvelteHTMLElements;
type __SvelteHTMLAttributesCompat<T extends EventTarget> =
  __SvelteHTMLAttributes<T> & svelteHTML.HTMLAttributes<T>;
type __SvelteEventProps<T> =
  T & { [K in keyof T as K extends `on:${infer E}` ? `on${E}` : never]?: T[K] };
type __SvelteElementAttributes<K extends string> =
  __SvelteEventProps<
    K extends keyof __SvelteIntrinsicElements
      ? __SvelteIntrinsicElements[K] & svelteHTML.HTMLAttributes<any>
      : __SvelteHTMLAttributesCompat<any>
  >;
type __SvelteEventHandler<K extends string, E extends string, A = {}> =
  A extends { [key in `on:${E}`]?: infer H }
    ? H | undefined
    : A extends { [key in `on${E}`]?: infer H }
      ? H | undefined
      : __SvelteElementAttributes<K> extends { [key in `on:${E}`]?: infer H }
        ? H | undefined
        : __SvelteElementAttributes<K> extends { [key in `on${E}`]?: infer H }
          ? H | undefined
          : ((e: Event) => void) | null | undefined;

type __SvelteAttachment<T extends EventTarget = Element> =
  (element: T) => void | (() => void);
declare function __svelte_ensure_attachment<T extends EventTarget>(
  attachment: __SvelteAttachment<T> | false | null | undefined,
  element: T
): void;

type __SvelteActionReturnType = {
  update?: (parameter: any) => void;
  destroy?: () => void;
  $$_attributes?: Record<string, any>;
} | void;
declare function __svelte_ensure_action<T extends __SvelteActionReturnType>(
  actionCall: T
): T extends { $$_attributes?: any } ? T["$$_attributes"] : {};

type __SvelteUnionToIntersection<U> =
  (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
declare function __svelte_union<T extends any[]>(...args: T): __SvelteUnionToIntersection<T[number]>;

declare function __svelte_create_element<K extends string, T>(
  tag: K | undefined | null,
  actionAttrs: T,
  attrs: __SvelteElementAttributes<K> & T
): void;

declare function __svelte_css_prop(props: Record<string, any>): {};

declare const __svelte_any: any;

// Component helper - returns the component as-is for type checking while
// widening empty-prop `Component` types and removing null/undefined.
declare function __svelte_ensure_component<T>(type: T): NonNullable<__SvelteCallableComponent<T>>;

declare module "svelte" {
  export function mount<Props extends Record<string, any>, Exports extends Record<string, any>>(
    component: __SvelteComponent<Props, Exports>,
    options: Omit<MountOptions<Props>, "props"> & {
      props: __SvelteLoosen<Props>;
    }
  ): Exports;
}


// === TEMPLATE TYPE-CHECK BLOCK ===
// This is never executed, just type-checked
async function __svelte_template_check__() {
  "red";
  "blue";
}

// === COMPONENT TYPE EXPORT ===
type __SvelteProps_Test_ = __SvelteLoosen<{}>;
declare const __SvelteComponent_Test_: __SvelteComponent<__SvelteProps_Test_>;
export default __SvelteComponent_Test_;


=== Source Map Mappings: 2 ===
